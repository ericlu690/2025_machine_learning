(get the code by dicussing with ChatGPT)
# --------------------------
# 0. 套件載入
# --------------------------
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from scipy.interpolate import griddata

# --------------------------
# 1. 讀入資料
# --------------------------
df_cls = pd.read_csv("classification_dataset.csv")
df_reg = pd.read_csv("regression_dataset.csv")

X_cls = df_cls[["longitude","latitude"]].values
y_cls = df_cls["is_valid"].astype(int).values
X_reg = df_reg[["longitude","latitude"]].values
y_reg = df_reg["temperature"].values

# --------------------------
# 2. GDA 分類器
# --------------------------
def fit_gda(X, y, reg=1e-6):
    n, d = X.shape
    phi = y.mean()
    mu0 = X[y==0].mean(axis=0)
    mu1 = X[y==1].mean(axis=0)
    sigma = sum([(X[i]-mu1).reshape(d,1)@(X[i]-mu1).reshape(1,d) if y[i]==1 else
                 (X[i]-mu0).reshape(d,1)@(X[i]-mu0).reshape(1,d) for i in range(n)])
    sigma /= n
    sigma += reg*np.eye(d)
    sigma_inv = np.linalg.pinv(sigma)
    w = sigma_inv.dot(mu1-mu0)
    b = -0.5*mu1.T.dot(sigma_inv).dot(mu1) + 0.5*mu0.T.dot(sigma_inv).dot(mu0) + np.log(phi/(1-phi))
    return {"w":w,"b":b}

def predict_gda(model, X):
    logits = X.dot(model["w"]) + model["b"]
    return (1/(1+np.exp(-logits)) >= 0.5).astype(int)

# Normalize features for GDA
cls_mean, cls_std = X_cls.mean(axis=0), X_cls.std(axis=0)
X_cls_norm = (X_cls - cls_mean)/cls_std

Xc_train, Xc_test, yc_train, yc_test = train_test_split(X_cls_norm, y_cls, test_size=0.3, random_state=1)
gda_model = fit_gda(Xc_train, yc_train)
C_all = predict_gda(gda_model, X_cls_norm)

# --------------------------
# 3. 多項式回歸 R(x)
# --------------------------
def poly2_features(X):
    x, y = X[:,0], X[:,1]
    return np.vstack([np.ones_like(x), x, y, x**2, x*y, y**2]).T

def fit_ridge(X, y, alpha=1e-3):
    Phi = poly2_features(X)
    return np.linalg.solve(Phi.T.dot(Phi)+alpha*np.eye(Phi.shape[1]), Phi.T.dot(y))

def predict_ridge(w, X):
    return poly2_features(X).dot(w)

w_reg = fit_ridge(X_reg, y_reg)
R_all = predict_ridge(w_reg, X_cls)

# --------------------------
# 4. 建構 h(x)
# --------------------------
h_all = np.where(C_all==1, R_all, -999.0)

# --------------------------
# 5. 建立網格
# --------------------------
lon_grid = np.linspace(X_cls[:,0].min(), X_cls[:,0].max(), 300)
lat_grid = np.linspace(X_cls[:,1].min(), X_cls[:,1].max(), 300)
XX, YY = np.meshgrid(lon_grid, lat_grid)
grid_pts = np.c_[XX.ravel(), YY.ravel()]

# GDA probability on grid
grid_norm = (grid_pts - cls_mean)/cls_std
probs_grid = (1/(1+np.exp(-(grid_norm.dot(gda_model["w"])+gda_model["b"])))).reshape(XX.shape)

# Ridge prediction on grid
R_grid = predict_ridge(w_reg, grid_pts).reshape(XX.shape)
h_grid = np.where(probs_grid>=0.5, R_grid, -999.0)

# --------------------------
# 6. 繪圖 A: 溫度等高線圖
# --------------------------
ZZ_temp = griddata((X_reg[:,0], X_reg[:,1]), y_reg, (XX, YY), method='cubic')
plt.figure(figsize=(9,7))
plt.contourf(XX, YY, ZZ_temp, levels=20, cmap="coolwarm", alpha=0.9)
plt.scatter(X_reg[:,0], X_reg[:,1], c=y_reg, cmap="coolwarm", s=8, edgecolors='k', linewidths=0.2)
plt.colorbar(label="Temperature")
plt.title("Temperature Contour Map")
plt.xlabel("Longitude"); plt.ylabel("Latitude")
plt.show()

# --------------------------
# 7. 繪圖 B: GDA 決策邊界 + 分類點
# --------------------------
plt.figure(figsize=(9,7))
plt.contourf(XX, YY, probs_grid, levels=50, cmap="coolwarm", alpha=0.6)
plt.contour(XX, YY, probs_grid, levels=[0.5], colors='k', linewidths=1.5)
plt.scatter(X_cls[:,0], X_cls[:,1], c=C_all, cmap="bwr", s=10, edgecolors='k', linewidths=0.1)
plt.title("GDA Decision Boundary with Classification Points")
plt.xlabel("Longitude"); plt.ylabel("Latitude")
plt.colorbar(label="Probability of is_valid=1")
plt.show()

# --------------------------
# 8. 繪圖 C: h(x) 空間分布
# --------------------------
h_flat = h_grid.ravel()
valid_mask = h_flat != -999
invalid_mask = h_flat == -999

plt.figure(figsize=(9,7))
plt.scatter(grid_pts[valid_mask,0], grid_pts[valid_mask,1], c=h_flat[valid_mask], s=12, cmap="viridis", label="h = R(x)")
plt.scatter(grid_pts[invalid_mask,0], grid_pts[invalid_mask,1], c='lightgray', s=8, label="h = -999")
plt.colorbar(label="h(x) / R_pred")
plt.title("Piecewise Function h(x) Distribution")
plt.xlabel("Longitude"); plt.ylabel("Latitude")
plt.legend()
plt.show()
