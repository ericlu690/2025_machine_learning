(The following code get by discussing with ChatGPT)
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 讀取資料
data = pd.read_csv("classification_dataset.csv")
X = data.iloc[:, :-1].values
y = data.iloc[:, -1].values

# 若資料維度超過2，只取前兩維方便可視化
if X.shape[1] > 2:
    X = X[:, :2]

# 轉換標籤
classes = np.unique(y)
class_map = {label: i for i, label in enumerate(classes)}
y = np.array([class_map[label] for label in y])

# 隨機抽一半資料
np.random.seed(42)
idx = np.random.choice(len(X), len(X)//2, replace=False)
X_sample = X[idx]
y_sample = y[idx]

# 定義 QDA 類別
class QDA:
    def __init__(self):
        self.means = {}
        self.covs = {}
        self.priors = {}
    
    def fit(self, X, y):
        self.classes = np.unique(y)
        for c in self.classes:
            X_c = X[y == c]
            self.means[c] = np.mean(X_c, axis=0)
            self.covs[c] = np.cov(X_c.T)
            self.priors[c] = len(X_c) / len(X)
    
    def _discriminant(self, X, c):
        mu = self.means[c]
        Sigma = self.covs[c]
        prior = self.priors[c]
        det = np.linalg.det(Sigma)
        inv = np.linalg.inv(Sigma)
        term1 = -0.5 * np.log(det)
        # 批次運算：逐筆樣本計算二次型
        diff = X - mu
        term2 = -0.5 * np.sum(diff @ inv * diff, axis=1)
        term3 = np.log(prior)
        return term1 + term2 + term3
    
    def predict(self, X):
        scores = np.array([self._discriminant(X, c) for c in self.classes])
        return np.argmax(scores, axis=0)

# 訓練 QDA 模型
qda = QDA()
qda.fit(X_sample, y_sample)

# 建立網格
x_min, x_max = X_sample[:, 0].min() - 0.5, X_sample[:, 0].max() + 0.5
y_min, y_max = X_sample[:, 1].min() - 0.5, X_sample[:, 1].max() + 0.5
xx, yy = np.meshgrid(np.linspace(x_min, x_max, 300),
                     np.linspace(y_min, y_max, 300))
grid = np.c_[xx.ravel(), yy.ravel()]

# 預測網格分類
Z = qda.predict(grid)
Z = Z.reshape(xx.shape)

# 視覺化
plt.figure(figsize=(8,6))
plt.contourf(xx, yy, Z, alpha=0.25, cmap='coolwarm')

# 淡紅 + 淡藍 + 半徑縮小
plt.scatter(X_sample[y_sample==0, 0], X_sample[y_sample==0, 1],
            color='lightcoral', alpha=0.6, s=20, label=f'Class {classes[0]}')
plt.scatter(X_sample[y_sample==1, 0], X_sample[y_sample==1, 1],
            color='lightskyblue', alpha=0.6, s=20, label=f'Class {classes[1]}')

plt.title("QDA Decision Boundary (Half Dataset)")
plt.xlabel("Feature 1")
plt.ylabel("Feature 2")
plt.legend()
plt.show()
